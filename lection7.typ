#import "notes.typ": *
#import "@preview/cetz:0.3.3"
#import "@preview/cetz-plot:0.1.1": *

#show math.lt.eq: math.lt.slant
#show math.gt.eq: math.gt.slant

= Лекция 7

== Открытая модель транспортной задачи

#definition[
  Транспортная задача --- задача с правильным балансом $ sum_i a_i = sum_j b_j $ А её модель называется закрытой.

  Иначе ($sum_i a_i != sum_j b_j$) задача называется задачей с неправильным балансом, а её модель называется открытой.

  Если $ sum_i a_i > sum_j b_j, $ то вводится фиктивный потребитель $b_(m+1)$ с потребностью равной $sum_i a_i - sum_j b_j$ и нулевыми тарифами в столбце перевозок.

  Если $ sum_i a_i < sum_j b_j, $ то вводится фиктивный поставщик $a_(n+1)$ с запасом равном $sum_j b_j - sum_i a_i$ и нулевыми тарифами в строке перевозок.
]
#let p = 0.8em
#let tr = place.with(top + right, dx: 0.8 * p, dy: -0.8 * p)
#let bl = place.with(bottom + left, dx: -0.8 * p, dy: 0.8 * p)
#let redbox = box.with(outset: 3pt, fill: red.lighten(80%), radius: 5pt)
#let greenbox = box.with(outset: 3pt, fill: green.lighten(80%), radius: 5pt)
#let bluebox = box.with(outset: 3pt, fill: blue.lighten(80%), radius: 5pt)
#let y = table.cell.with(fill: yellow.lighten(80%))
#let r = table.cell.with(fill: red.lighten(80%))
#let b = table.cell.with(fill: blue.lighten(70%))
#let txr = text.with(fill: red)
#example(title: "Открытая модель транспортной задачи")[
  #figure(
    table(
      columns: (auto, 8%, 8%, 8%, 8%, 8%, 10%, 5%, 5%, 5%, 5%),
      inset: p,
      align: center + horizon,
      [#place(top + right, dx: 0.6 * p, dy: -0.6 * p)[$v_j$] #place(
          bottom + left,
          dx: -0.6 * p,
          dy: 0.6 * p,
        )[$u_i$] #line(
          start: (-0.7 * p, -0.7 * p),
          end: (0.7 * p, 0.7 * p),
        )],
      [0],
      [3],
      [4],
      [2],
      [-3],
      [$sum b_j$],
      [],
      [],
      [],
      [],

      bluebox[0],
      [#tr[11]#bl[-11]---],
      [#tr[5]#bl[-2]---],
      [#tr[4]10],
      [#tr[2]90],
      [#tr[0]#bl[-3]---],
      [100],
      [2],
      [2],
      [4],
      [1],

      [1], [#tr[1]70], [#tr[4]60], [#tr[5]70], [#tr[9]#bl[-6]---], [#tr[0]#bl[-2]---], [200], [1], [4], [4], [1],
      [3],
      [#tr[9]#bl[-6]---],
      [#tr[8]#bl[-2]---],
      [#tr[7]100],
      [#tr[10]#bl[-5]---],
      [#tr[0]30],
      [130],
      [7],
      [7],
      r[7],
      [1],

      table.cell(inset: 0.1em)[$sum a_i$], [70], [60], [180], [90], [30], [], [], [], [], [],
      [], r[8], [1], [1], [7], [0], [], [], [], [], [],
      [], [], [1], [1], r[7], [0], [], [], [], [], [],
      [], [], [1], [1], [], [0], [], [], [], [], [],
      [], [], r[1], [1], [], [], [], [], [], [], [],
    ),
    caption: "",
  )
  $
    X^* = mat(0,0,10,90,cancel(0, stroke: #{red+1.5pt});70,60,70,0,cancel(0, stroke: #{red+1.5pt});0,0,100,0,cancel(30, stroke: #{red+1.5pt}))
  $
  Последний столбец вычеркнули так как это был фиктивный потребитель.
  $ F(X^*) = 40+180+70+240+350+700 = 1580 $

]

#example[

  #figure(
    table(
      columns: (auto, 8%, 8%, 8%, 8%, 8%),
      inset: p,
      align: center + horizon,
      [#place(top + right, dx: 0.6 * p, dy: -0.6 * p)[$v_j$] #place(
          bottom + left,
          dx: -0.6 * p,
          dy: 0.6 * p,
        )[$u_i$] #line(
          start: (-0.7 * p, -0.7 * p),
          end: (0.7 * p, 0.7 * p),
        )],
      [3],
      [8],
      [1],
      [10],
      [$sum b_j$],

      [6], [#tr[4]#bl[#greenbox[5]]---], [#tr[14]60], [#tr[11]#bl[-4]---], [#tr[11]#bl[-6]---], [60],
      bluebox[0], [#tr[3]60], [#tr[17]#bl[-9]---], [#tr[1]30], [#tr[10]40], [130],
      [8], [#tr[9]#bl[-2]---], [#tr[16]40], [#tr[11]#bl[-2]---], [#tr[18]80], [120],
      [-10], [#tr[0]#bl[-7]---], [#tr[0]#bl[-2]---], [#tr[0]#bl[-9]---], [#tr[0]40], [40],
      [$sum a_i$], [60], [100], [30], [160], [],
    ),
    caption: "",
  )
  $ n+m-1=7 $
  Количество заполненных клеток так же равно 7 $=>$ *задача является невырожденной*.

  Если бы количество заполненных было меньше, то задача бы была вырожденной, в таком случае нужно заполнить нулями клетки с минимальным тарифом.

  Нашли положительный потенциал #greenbox[5], от него двигаемся:
  #let b = $arrow.b$
  #let t = $arrow.t$
  #let l = $arrow.l$
  #let r = $arrow$
  #r #b #b #r #r #t #l #l #l #t циклом, ставя + и - в поворотах, выбираем оттуда числа, которые в этом процессе стали отрицательными. Из них выбираем минимум
  $ S = min{60, 80} = 60 $
  Ставим это число в клетку с положительным потенциалом, теперь нужно пересчитать с нуля все потенциалы.

  #figure(
    table(
      columns: (auto, 8%, 8%, 8%, 8%, 8%),
      inset: p,
      align: center + horizon,
      [#place(top + right, dx: 0.6 * p, dy: -0.6 * p)[$v_j$] #place(
          bottom + left,
          dx: -0.6 * p,
          dy: 0.6 * p,
        )[$u_i$] #line(
          start: (-0.7 * p, -0.7 * p),
          end: (0.7 * p, 0.7 * p),
        )],
      [3],
      [8],
      [1],
      [10],
      [$sum b_j$],

      [1], [#tr[4]60], [#tr[14]#bl[-5]---], [#tr[11]#bl[-9]---], [#tr[11]#bl[-3]---], [60],
      bluebox[0], [#tr[3]0], [#tr[17]#bl[-9]---], [#tr[1]30], [#tr[10]100], [130],
      [8], [#tr[9]#bl[#greenbox[2]]---], [#tr[16]100], [#tr[11]#bl[-2]---], [#tr[18]20], [120],
      [-10], [#tr[0]#bl[-7]---], [#tr[0]#bl[-2]---], [#tr[0]#bl[-9]---], [#tr[0]40], [40],
      [$sum a_i$], [60], [100], [30], [160], [],
    ),
    caption: "",
  )

  Опять есть положительный потенциал #greenbox[2], двигаемся от него циклом:
  #t #r #r #r #b #l #l #l, получаем, что:
  $ S = min{0,20} = 0 $

  #remark[Если величина сдвига равна 0, то в исходной клетке ставим 0, а в той, где был 0 ставим --- (становится свободной).]

  #figure(
    table(
      columns: (auto, 8%, 8%, 8%, 8%, 8%),
      inset: p,
      align: center + horizon,
      [#place(top + right, dx: 0.6 * p, dy: -0.6 * p)[$v_j$] #place(
          bottom + left,
          dx: -0.6 * p,
          dy: 0.6 * p,
        )[$u_i$] #line(
          start: (-0.7 * p, -0.7 * p),
          end: (0.7 * p, 0.7 * p),
        )],
      [1],
      [8],
      [1],
      [10],
      [$sum b_j$],

      [3], [#tr[4]60], [#tr[14]#bl[-3]---], [#tr[11]#bl[-7]---], [#tr[11]#bl[-5]---], [60],
      bluebox[0], [#tr[3]#bl[-2]---], [#tr[17]#bl[-9]---], [#tr[1]30], [#tr[10]100], [130],
      [8], [#tr[9]0], [#tr[16]100], [#tr[11]#bl[-2]---], [#tr[18]20], [120],
      [-10], [#tr[0]#bl[-9]---], [#tr[0]#bl[-2]---], [#tr[0]#bl[-9]---], [#tr[0]40], [40],
      [$sum a_i$], [60], [100], [30], [160], [],
    ),
    caption: "",
  )

  $
    X^* = mat(60,0,0,0;0,0,30,100;0,100,0,20;)
  $
  $ F(X^*) = 3230 $
]

== Определение оптимального плана транспортной задачи с дополнительными ограничениями.

При решении транспортных задач необходимо учитывать дополнительные ограниче
ния на перевозки. Далее рассмотрим различные варианты сведения таких транспортных задач к закрытой транспортной задаче.

+ Если в закрытой транспортной задаче перевозки от поставщика $A_i$ к потребителю $B_j$ не могут быть осуществлены (блокировка), то для определения оптимального решения предполагают, что тариф перевозки единицы груза от $A_i$ к $B_j$ равен сколь угодно большому числу $M$.
+ Если дополнительным условием в транспортной задаче является обеспечение перевозки от поставщика $A_i$ к потребителю $B_j$ в точности $a_(i j)$, то в клетку с номером $(i,j)$ записывают указанное число, а эту клетку считают свободной со сколь угодно большим тарифом $M$.
+ Если от поставщика $A_i$ к потребителю $B_j$ должно быть перевезено не менее $a_(i j)$ единиц груза, то запасы пункта $A_i$ и потребности пункта $B_j$ полагают меньше фактических на $a_(i j)$ единиц. После нахождения оптимального плана перевозку стоящую в клетке с номером $(i,j)$ увеличивают на величину $a_(i j)$.
+ Если от поставщика $A_i$ к потребителю $B_j$ требуется перевезти не более $a_(i j)$ единиц груза, то вводят дополнительного потребителя $B_(N+1)$, к которому записывают те же тарифы, что и для потребителя $B_i$ за исключением тарифа в $i$-ой строке, который считают равным сколь угодно большому числу $M$. Потребности пункта $b_j$ считают равными $a_(i j)$, а потребности $B_(N+1)$ полагают равными $b_j-a_(i j)$.

#example[
  Найти решение транспортной задачи с заданной таблицей, если из $A_3$ в $B_1$ и из $A_2$ в $B_3$ перевозки не могут быть осуществлены, из $A_1$ в $B_2$ должно быть завезено _не менее_ 30 единиц груза, а из $A_2$ в $B_4$ _ровно_ 70 единиц.

  _у доски был_
]

== Динамическое программирование

Пусть поведение технической или экономической системы описывается уравнением
$
  dot(x) = f(x,u,t), quad cases("переменные", x in RR^N, x=x(t)), quad cases("управляющие воздействия",u in U subset RR^M, u=u(t))
$

Начальное условие: $x(0)=x_0$.

Задан функционал:
$ I = limits(integral)_0^T F(x,u,t) d t -> min $

Метод динамического программирования основывается на принципе оптимальности Беллмана.

#theorem(
  title: "Принцип оптимальности Беллмана",
)[Последний участок оптимальной траектории должнен быть оптимальной траекторией(минимизирующей данный функционал).]
#proof[
  Пусть есть траектория оптимальная траектория $[x^0, ..., x^T]$. Возьмем на ней точку $x(t_1)$, обозначим участок $ I: [x^0, ..., x(t_1)]\ I I: [x(t_1), ..., x^T] $

  Интеграл по оптимальной траектории:
  $ I_1 = limits(integral)_0^T F(I) d t + limits(integral)_0^T F(I I) d t $

  Если предположить, что принцип оптимальной траектории неверен, то существует участок $ I I I = [x(t_1), ...] $ отличный от вышеперечисленных и интеграл по траектории, содержащей его:
  $ I_2 = limits(integral)_0^T F(I) d t + limits(integral)_0^T F(I I I) d t $

  Сравним эти интегралы:
  $
    I_1 = limits(integral)_0^T &F(I) d t + &limits(integral)_0^T F(I I) d t & \
    &#rotate(90deg, $=$) &#rotate(90deg, $<$) &=> I_2>I_1 \
    I_2 = limits(integral)_0^T &F(I) d t + &limits(integral)_0^T F(I I I) d t &
  $

  Пришли к противоречию.
]

