#import "notes.typ": *
#import "@preview/cetz:0.3.3"
#import "@preview/cetz-plot:0.1.1": *

#show math.lt.eq: math.lt.slant
#show math.gt.eq: math.gt.slant

= Лекция 4

#example[
  #smallcaps[Условие.]

  Фирма А продаёт некоторый сезонный товар, который имеет спрос в течение $n$ единиц времени. Этот товар поступает на рынок в момент $i in [1,n]$. Для конкурентной борьбы с фирмой А, дочерняя фирма Б концерна Д, не заботясь о собственных доходах, производит аналогичный товар, который поступает на рынок в момент $j in [1,n]$.

  Цель фирмы Б --- это разорение фирмы А, после чего опираясь на капитал Д, ей будет легко наверстать упущенное. Единственным законным инструментом фирмы Б является выбор момента поступления товара на рынок. Для разорения фирмы А фирма Б должна минимизировать её доходы.

  Качество конкурирующих товаров зависит от времени их поступления на рынок. Чем позже товар поступает, тем качество его выше, а реализуется товар только более высокого качества.

  Если фирма А выбросит свой товар в момент $i$, а фирма Б в момент $j>i$, то фирма А, не имея конкурента, в течение $j-i$ единиц времени получит за это время доход $C(j-i)$, где $C$ --- доход от продажи товара в единицу времени. В момент времени $j$ на рынке появляется товар фирмы Б, который имеет более высокое качество, поэтому с момента $j$ фирма А теряет рынок и в дальнейшем дохода не получает.

  Если $i>j$, то фирма А выбросив на рынок более качественный товар будет получать доход в течение всего отрезка $[i,n]$, так как число оставшихся единиц времени $n-i+1$, то доход фирмы А будет равен $C(n-i+1)$, где $C$ --- доход от продажи товара в единицу времени.

  В том случае, когда $i=j$, то есть на рынок одновременно поступает оба товара, спрос будет одинаковым, и поэтому фирма А получит доход равный $C(n-i+1)/2$. Фирма А выбирает $i$-ую единицу времени поступления товара на рынок, стремясь максимизировать свой доход, а фирма Б выбирает $j$-ую единицу времени и стремится минимизировать доход фирмы А.

  Построить платежную матрицу. Найти решение данной игры. $n=4$.

  #smallcaps[Решение.]

  #list(
    marker: [$star$],
    [$j>i => C(j-i)$],
    [$j<i => C(n-i+1)$],
    [$j=i => C(n-i+1) / 2$],
  )
  #figure(
    table(
      columns: 5,
      inset: 8pt,
      [], [B1], [B2], [B3], [B4],
      [A1], [$2C$], [$C$], [$2C$], [$3C$],
      [A2], [$3C$], [$3 / 2 C$], [$C$], [$2C$],
      [A3], [$2C$], [$2C$], [$C$], [$C$],
      [A4], [$C$], [$C$], [$C$], [$C / 2$],
    ),
  )
  Поделим на C:
  $
    mat(
      2, 1, 2, 3;
      3, 3 / 2, 1, 2;
      2, 2, 1, 1;
      1, 1, 1, 1 / 2;
    )
  $
  Вычеркиваем 1,4 столбцы и 2, 4 строку, по принципу доминирования.
  $
    mat(
       1, 2;
       2, 1;
    )
  $
  Проверим наличие седловой точки:
  $ max_i min_j a_(i j) = alpha = 2 $
  $ min_j max_i a_(i j) = beta = 1 $
  $alpha!=beta =>$ седловой точки нет.
  $
    cases(
      p_1+2p_3=V,
      2p_1+p_3=V,
      p_1+p_3=1
    )quad
    cases(
      q_2+2q_3=V,
      2q_2+q_3=V,
      q_2+q_3=1
    )
  $
  $
    dash(p)=(1 / 2, 0, 1 / 2, 0), quad V=3 / 2,quad dash(q)=(0,1 / 2,1 / 2,0).
  $
]

#example[
  Платежная матрица:
  $
    mat(1.5,3;2,1;)
  $
  $
    cases(
      1.5p_1+3p_2=V,
      2p_1+p_2=V,
      p_1+p_2=1
    )quad
    cases(
      1.5q_1+3q_2=V,
      2q_1+q_2=V,
      q_1+q_2=1
    )
  $
  $
    dash(p)=(2 / 5,3 / 5),quad V=7 / 5,\ dash(q)=(1 / 5,4 / 5),quad V=7 / 5.
  $
  #figure(
    cetz.canvas(
      {
        import cetz.draw: *
        set-style(
          axes: (
            stroke: (thickness: .5pt, dash: none, paint: auto),
            tick: (stroke: .5pt),
          ),
          legend: (stroke: none, orientation: ttb, item: (spacing: .1), scale: 5%),
        )
        let domain = (-5, 20)
        // set-style(mark: (symbol: ">"))
        plot.plot(
          name: "plot",
          axis-style: "school-book",
          x-min: -0.4,
          x-max: 3,
          y-min: -0.4,
          y-max: 4,
          y-tick-step: .5,
          x-tick-step: .5,
          // x-label: $x_1$,
          // y-label: $x_2$,
          {
            plot.add-vline(1, min: 0)
            plot.add-anchor("a", (0, 1.5))
            plot.add-anchor("b", (0, 3))
            plot.add-anchor("c", (1, 1))
            plot.add-anchor("d", (1, 2.5))
          },
        )
        line("plot.b", "plot.c")
        line("plot.a", "plot.d")
      },
      length: 60%,
    ),
    // caption: "Допустимая область",
  )
  $
    (x-0) / 1=(y-1.5) / 0.5
  $
  Точка пересечения:
  $ cases(y=0.5x+1.5,y=-2x+3)=>cases(x=3/5=p_2,V=y=9/5) $
  Аналогично для $q$:
  // $ cases() $
]

#example[
  $
    mat(
    3,4,3,-2;
    4,3,2,6;
    3,2,1,-3;
  )
  $
  Вычеркиваем 3 строчку. Вычеркиваем 1,2 столбцы:
  $
    mat(3,-2;2,6;)
  $
  $
    cases(3p_1+2p_2=V,-2p_1+6p_2=V, p_1+p_2=1) quad
    cases(3q_3-2q_4=V,2q_3+6q_4=V, q_3+q_4=1)
  $
  $
    dash(p)=(4 / 9,5 / 9,0), quad V=29 / 9\
    dash(q)=(0,0,8 / 9,1 / 9), quad V=22 / 9
  $
]

#example[
  $ mat(4,2,0;0,5,0;2,1,3;) $
  Получим задачу линейного программирования для игрока A.
  $
    cases(
    &4p_1&+&2p_3&=V,
    &2p_1+&5p_2+&p_3&=V,
    &&&3p_3&=V,
    &p_1+&p_2+&p_3&=1
  )=>
    cases(
    &4p_1&+&2p_3&>=V,
    &2p_1+&5p_2+&p_3&>=V,
    &&&3p_3&>=V,
    &p_1+&p_2+&p_3&=1
  ) stretch(=>)^(x_i=p_i / V)
    cases(
    &4x_1&+&2x_3&>=1,
    &2x_1+&5x_2+&x_3&>=1,
    &&&3x_3&>=1,
    &x_1+&x_2+&x_3&=1/V -> min
  )
  $
  Аналогично для игрока B:
  $
    cases(
      &4y_1+&2y_2& &<=1,
      &&5y_2& &<=1,
      &2y_1+&y_2+&3y_3&<=1,
      &y_1+&y_2+&y_3&=1/V ->max
    )
  $
  Решим симплекс методом:
  Симплекс таблица:

  #box(fill: red.lighten(80%), outset: 4pt, "   ") --- выбранный разрешающий столбец

  #box(fill: yellow.lighten(80%), outset: 4pt, "   ") --- элемент, для которого $b_i/a_(i j)=min{b_i / a_(i j)}$

  #box(fill: blue.lighten(70%), outset: 4pt, "   ") --- элемент с которым произведены действия

  #let y = table.cell.with(fill: yellow.lighten(80%))
  #let r = table.cell.with(fill: red.lighten(80%))
  #let b = table.cell.with(fill: blue.lighten(70%))
  #figure(
    table(
      columns: (1.5fr, 1fr, 1fr, 1.5fr, 1.5fr, 1.5fr, 1.5fr, 1.5fr, 1.5fr, 2.5fr),
      inset: 10pt,
      align: horizon + center,
      fill: (x, y) => if x == 0 or y == 0 {
        gray.lighten(50%)
      } else if calc.rem(y, 4) == 0 {
        gray.lighten(85%)
      },
      [*Шаг*], [*БН*], [*СЧ*], [$bold(y_1)$], [$bold(y_2)$], [$bold(y_3)$], [$bold(y_4)$], [$bold(y_5)$], [$bold(y_6)$], [#text(
          size: 6pt,
        )[*Вычисления*]],
      row-gutter: (0pt, 0pt, 0pt, 0pt, 3pt, 0pt, 0pt, 0pt, 3pt, 0pt),
      column-gutter: (0pt, 0pt, 2.5pt, 0pt),
      table.cell(rowspan: 4)[*1*],
      [$y_4$], [1], y[4], [2], [0], [1], [0], [0], y[$1 / 4$],
      [$y_5$], [1], r[0], [5], [0], [0], [1], [0], [$in.not RR$],
      [$y_6$], [1], r[2], [1], [3], [0], [0], [1], [$1 / 2$],
      [$phi$], [0], r[-1], [-1], [-1], [0], [0], [0], [],

      table.cell(rowspan: 4)[*2*],
      [$y_1$], [], [], [], [], [], [], [], [],
      [$y_5$], [], [], [], [], [], [], [], [],
      [$y_6$], [], [], [], [], [], [], [], [],
      [$phi$], [], [], [], [], [], [], [], [],

      table.cell(rowspan: 4)[*3*],
      [$y_1$], [$1 / 4$], [1], r[$1 / 2$], [0], [$1 / 4$], [0], [0], [$(1\/4) / (1\/2)=2$],
      [$y_5$], [1], [0], y[5], [0], [0], [1], [0], y[$1 / 5$],
      [$y_3$], [$1 / 6$], [0], r[0], [1], [$-1 / 6$], [0], [$1 / 3$], [$in.not RR$],
      [$phi$], [$5 / 12$], [0], r[$-1 / 2$], [0], [$1 / 12$], [0], [$1 / 3$], [],

      table.cell(rowspan: 4)[*4*],
      [$y_1$], [$3 / 20$], table.cell(
        colspan: 7,
        rowspan: 4,
      )[не пишем тк нам это уже не нужно, мы знаем, что здесь всё будет ОК $checkmark$],
      [$y_2$], [$1 / 5$],
      [$y_3$], [$1 / 6$],
      [$phi$], [$31 / 60$],
    ),
  )

  Условия дополняющей нежесткости:
  $
    cases(
      (4y_1^*+2y_2^*-1)x_1^*=0,
      (5y_2^*-1)x_2^*=0,
      (2y_1^*+y_2^*+y_3^*-1)=0,
      ,
      (4x_1^*+2x_3^*-1)y_1^*=0,
      (2x_1^*+5x_2^*+x_3^*-1)y_2^*=0,
      (3x_3^*-1)y_3^*=0
    )
  $
]
