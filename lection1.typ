#import "notes.typ": *
#import "@preview/cetz:0.3.3"
#import "@preview/cetz-plot:0.1.1": *

= Лекция 1. Элементы теории игр. Игры с природой
Далее будем рассматривать следующие разделы:

+ игры с природой. когда присутствует человек (лицо, принимающее решения) и природа. Человек отличается от природы тем, что природа независима/непредсказуема.

+ антагонистические игры с нулевой суммой. Нулевая сумма -- выигрыш одного игрока равен проигрышу другого.

#definition(title: "Платежная матрица")[
  Игра задается платежной матрицей $C$. Элемент матрицы $C_(i j)$ означает выигрыш игрока $A$ и соответственно проигрыш игрока $B$ в том случае, когда игрок $A$ использует $i$-ую стратегию, а игрок $B$ использует $j$-ую стратегию.
]

#example[Если $C_(1 1)=-1$, то игрок $A$ проиграл, $B$ выиграл, выигрыш равен 1.]
#example(title: "Задача")[
  Руководство универмага заказывает товар вида $A$. Известно, что спрос на данный вид товара лежит в пределах $[6, 9]$ единиц. Если заказанного товара окажется недостаточно для удовлетворения спроса, то руководство может срочно заказать и завести недостающее количество. Если же спрос будет меньше наличного количества товара, то нереализованный товар хранится на складе универмага.

  Требуется определить такой объем заказа на товар, при котором дополнительные затраты, связанные с хранением и срочным завозом, были бы минимальные. Если расходы на хранение единицы товара составляют $1000$УЕ, а по срочному заказу и завозу $2000$УЕ.
]
#smallcaps[Решение.]

Стратегий у руководства: 4, так как оно может заказать 6, 7, 8, 9 (стратегии А1, А2, А3, А4 соответственно) единиц товара. Пусть игрок будет $A$, его стратегии $A_1, A_2, ...$. Природу обозначаем $П$, её стратегии $П_1, ...$. Составим платежную матрицу, см. @plat_mat_ex1.

#figure(
  table(
    columns: 5,
    [], [$П_1$], [$П_2$], [$П_3$], [$П_4$],
    [$A_1$], [0], [-2], [-4], [-6],
    [$A_2$], [-1], [0], [-2], [-4],
    [$A_3$], [-2], [-1], [0], [-2],
    [$A_4$], [-3], [-2], [-1], [0],
  ),
  caption: [Платежная матрица. Выше главной диагонали --- траты на заказ доп. товара, ниже --- траты за хранение лишнего товара на складе.],
)<plat_mat_ex1>

Если к платежной матрице добавить некоторое число, то это не влияет на выбор стратегии, но при этом цена игры меняется на это число.

Преобразуем матрицу, добавив число 6 ко всем элемента (чтобы все элементы стали неотрицательными).
#figure(
  table(
    columns: 6,
    [], [$П_1$], [$П_2$], [$П_3$], [$П_4$], [$min$],
    [$A_1$], [6], [4], [2], [0], [0],
    [$A_2$], [5], [6], [4], [2], [2],
    [$A_3$], [4], [5], [6], [4], [4],
    [$A_4$], [3], [4], [5], [6], [3],
  ),
  caption: [Преобразованная платежная матрица],
)<plat_mat2_ex1>
Подсчитаем также наименьший проигрыш при каждой стратегии, см @plat_mat2_ex1


#definition(title: "Критерий Вальда (крайнего пессимизма)")[
  Лицо принимающее решение действует исходя из предположения, что ему всё время не везёт.
  Оптимальная стратегия -- та, у которой наибольшее значение.
]

Тогда по критерию Вальда выбираем стратегию A3.

#definition(title: "Критерий Гурвица")[
  $
    Z_i = alpha D_i + (1-alpha)P_i,
  $
  где $D_i$ -- минимум в строке платежной матрицы, $P_i$ -- максимум.
  Оптимальная стратегия -- та, у которой наибольшее значение $Z_i$.
]
#figure(
  table(
    columns: 8,
    inset: 6pt,
    [], [$П_1$], [$П_2$], [$П_3$], [$П_4$], [$D_i=min$], [$P_i=max$], [$Z_i$],
    [$A_1$], [6], [4], [2], [0], [0], [6], [3],
    [$A_2$], [5], [6], [4], [2], [2], [6], [4],
    [$A_3$], [4], [5], [6], [4], [4], [6], [5],
    [$A_4$], [3], [4], [5], [6], [3], [6], [$9 / 2$],
  ),
  caption: [Подсчеты для критерия Гурвица],
)
По критерию Гурвица выбираем стратегию A3.

Составим матрицу риска (недобор до максимума, в нашем случае 6):
#figure(
  table(
    columns: 5,
    inset: 6pt,
    [$A_1$], [0], [2], [4], [6],
    [$A_2$], [1], [0], [2], [4],
    [$A_3$], [2], [1], [0], [2],
    [$A_4$], [3], [2], [1], [0],
  ),
  caption: [Матрица риска],
)
#definition(title: "Критерий Севиджа")[
  Для каждой строки матрицы риска выбираем максимум риска. Строка с наименьшим максимумом -- оптимальная стратегия.
]
По критерию Сэвиджа выбираем A3.

#definition(title: "Критерий Байеса-Лапласа I")[
  Предполагается известной вероятность постпления каждого состояния, если такой информации нет, то все состояния природы считаем равновероятными.
]
#todo[Критерий Байеса-Лапласа II]
#figure(
  table(
    columns: 7,
    inset: 6pt,
    [], [], [], [], [], [I], [II],
    [$A_1$], [0], [2], [4], [6], [$3$], [$3$],
    [$A_2$], [1], [0], [2], [4], [$4.25$], [$1.75$],
    [$A_3$], [2], [1], [0], [2], [$4.75$], [$1.25$],
    [$A_4$], [3], [2], [1], [0], [$4.5$], [$1.5$],
  ),
  caption: [Подсчеты для критериев Байеса-Лапласа I/II],
)

По обоим критериям Байеса-Лапласа I/II выбираем А3.
#qed()

== Линейное программирование
$ f(x) = (c, x) = sum c_i x_i = ||c||dot||x|| cos alpha $
$ (z,c) = sum z_i c_i = sum (x_0 - x_i^0) c_i = sum x_i c_i - A = 0 $
// Допустим
#figure(
  cetz.canvas(
    {
      import cetz.draw: *
      let domain = (-1, 1)
      plot.plot(
        axis-style: "school-book",
        x-tick-step: none,
        y-tick-step: none,
        {
          plot.add(((0, 0), (1, 1)), domain: domain)
          plot.add(((-1, 1), (1, -1)), domain: domain)
        },
      )
    },
    length: 40%,
  ),
)

Поверхности уровня --- это гиперплоскости ортогональные вектору $c$.

$ X_c = { x | f(x)=c } $

Рассмотрим функцию $z = x^2 + y^2$. Её поверхность уровня.
#figure(
  cetz.canvas(
    {
      import cetz.draw: *
      let domain = (-2, 2)
      plot.plot(
        axis-style: "school-book",
        x-tick-step: none,
        y-tick-step: none,
        {
          plot.add-contour(
            (x, y) => { x * x + y * y },
            x-domain: domain,
            y-domain: domain,
            fill: true,
            style: (fill: rgb(50, 50, 250, 50)),
            op: "<",
            z: (4, 3, 2, 1),
          )
        },
      )
    },
    length: 60%,
  ),
)

#definition(title: "Задача математического программирования")[
  Задача математического программирования:
  $
    A: cases(
    phi(x) -> min,
    g_i(x) <= 0\, quad i=overline(1\,L)
  )
  $
]

#definition(title: "Задача линейного программирования")[
  Если в задаче $A$ математического программирования функция $phi(x)$ -- линейная, ограничения $g_i$ -- линейные, то такая задача $A$ называется _задачей линейного программирования_.
]

Обычно для решения задач линейного программирования используется алгоритм _симлекс-метод_.

#example[
  Решить симплекс-методом:
  $
    f(x) = 2x_2 -> max
  $
  $
    cases(
      &x_1 + &x_2 <= 1,
      -&x_1 + &x_2 <= 1,
      &x_1 - &x_2 <= 1,
      -&x_1 - &x_2 <= 1
    )
  $

  #smallcaps[Решение.]

  Записываем уравнение прямой в отрезках $x/a + y/b = 1$, получаем:
  $
    cases(
      &x_1 + &x_2 <= 1 quad &-> quad x_1/1 + x_2/1=1,
      -&x_1 + &x_2 <= 1 quad &-> quad x_1/(-1) + x_2/1=1,
      &x_1 - &x_2 <= 1 quad &-> quad x_1/1 + x_2/(-1)=1,
      -&x_1 - &x_2 <= 1 quad &-> quad x_1/(-1) + x_2/(-1)=1
    )
  $

  #figure(
    cetz.canvas(
      {
        import cetz.draw: *
        let domain = (-1.1, 1.1)
        plot.plot(
          axis-style: "school-book",
          x-tick-step: none,
          y-tick-step: none,
          y-min: -1.1,
          y-max: 1.1,
          {
            plot.add(x => x + 1, domain: domain)
            plot.add(x => x - 1, domain: domain)
            plot.add(x => -x + 1, domain: domain)
            plot.add(x => -x - 1, domain: domain)
            plot.add-fill-between(
              x => x + 1,
              x => x - 1,
              domain: (-1, 1),
            )
            // plot.add-fill-between(
            //   x => -x - 1,
            //   x => -x + 1,
            //   domain: (0, 1),
            // )
          },
        )
      },
      length: 40%,
    ),
  )
  #todo[рисунки и выводы о решениях]
  В данном случае задача имеет единственое решение в вершине многогранника допустимых значений.

  В данном случае решение задачи не ограниченно.
  #figure(
    cetz.canvas(
      {
        import cetz.draw: *
        let domain = (-1.1, 1.1)
        plot.plot(
          axis-style: "school-book",
          x-tick-step: none,
          y-tick-step: none,
          y-min: -1.1,
          y-max: 1.1,
          {
            plot.add(x => x + 1, domain: domain)
            plot.add(x => x - 1, domain: domain)
            plot.add(x => -x + 1, domain: domain)
            plot.add(x => -x - 1, domain: domain)
            plot.add-fill-between(
              x => x + 1,
              x => x + 10,
              domain: (-1, 1),
            )
            plot.add-fill-between(
              x => x - 1,
              x => x - 10,
              domain: (-1, 1),
            )
            plot.add-fill-between(
              x => -x - 1,
              x => -x - 10,
              domain: (-1, 1),
            )
            plot.add-fill-between(
              x => -x + 1,
              x => -x + 10,
              domain: (-1, 1),
            )
            // plot.add-fill-between(
            //   x => -x - 1,
            //   x => -x + 1,
            //   domain: (0, 1),
            // )
          },
        )
      },
      length: 40%,
    ),
  )

  #qed()
]

#example[
  $
    f(x)=x_1+x_2+x_3 -> min, max
  $
  $
    cases(
      x_1 + 2x_2 <= 16\, quad -> quad  x_1/16 + x_2/7 = 1: l_1,
      2x_1 + x_2 <= 14\, quad -> quad  x_1/7+x_2/14=1: l_2,
      3x_1 + x_1 >= 6\, quad -> quad  x_1/2+x_2/6=1: l_3,
      x_1 >= 0\,,
      x_2 >= 0.,
    )
  $
  #figure(
    cetz.canvas(
      {
        import cetz.draw: *
        let domain = (-20, 20)
        plot.plot(
          axis-style: "school-book",
          x-tick-step: 2,
          y-tick-step: 2,
          y-min: -2,
          y-max: 15,
          x-min: -4,
          {
            plot.add(x => (1 - x / 16) * 7, domain: domain, label: [$l_1$])
            plot.add(x => (1 - x / 7) * 14, domain: domain, label: [$l_2$])
            plot.add(x => (1 - x / 2) * 6, domain: domain, label: [$l_3$])
          },
        )
      },
      length: 40%,
    ),
  )
]

#definition(title: "Канонический вид задачи")[
  Если все ограничения в задаче линейного программирования записаны в виде *равенств*, то говорят, что задача линейного программирования записана в каноническом виде.
]
#definition(title: "Стандартный вид задачи")[
  Если все ограничения в задаче линейного программирования записаны в виде *неравенств*, то говорят, что задача линейного программирования записана в каноническом виде.
]

#example[
  $
    f(x) = x_1-3x_2+2x_3 -> max
  $
  $
    cases(
      2x_1-x_2-x_3=-2,
      x_1-2x_2+x_4=2,
      x_1+x_2+x_5=5,
      x_i>=0\,quad i=overline(1\,5)
    ) arrow.r.double
    cases(
      2x_1-x_2<=-2 quad -> quad x_1/(-1) + x_2/2 = 1: l_1,
      x_1-2x_2<=2 quad -> quad x_1/2+x_2/(-1)=1: l_2,
      x_1+x_2<=5 quad -> quad x_1/5+x_2/5=1: l_3,
    )
  $
  #figure(
    cetz.canvas(
      {
        import cetz.draw: *
        let domain = (-2, 6)
        plot.plot(
          axis-style: "school-book",
          x-tick-step: 2,
          y-tick-step: 2,
          y-min: -2,
          y-max: 6,
          x-min: -2,
          {
            plot.add(x => (1 - x / (-1)) * 2, domain: domain, label: [$l_1$])
            plot.add(x => (1 - x / 2) * (-1), domain: domain, label: [$l_2$])
            plot.add(x => (1 - x / 5) * 5, domain: domain, label: [$l_3$])
          },
        )
      },
      length: 40%,
    ),
  )
  #todo[дописать решение]
]

#example[
  $
    cases(
       &x_1+2&x_2+3x_3&=-4,
      2&x_1+ &x_2&=19,
      3&x_1+4&x_2+5x_3&=6
    )
  $
  $
    mat(
      1, 2, 3 , 4;
      2, 1, 0 , 19;
      3, 4, 5, 6;
      augment: #3
    ) ~
    mat(
      1, 2, 3, -4;
      0, -3, -6, -27;
      0, -2, -4, 18;
      augment: #3
    ) ~
    mat(
      1, 2, 3, -4;
      0, 1, 2, -9;
      0, 1, 2, -9;
      augment: #3
    ) ~
    mat(
      1, 0, -1, -14;
      0, 1, 2, -9;
      augment: #3
    )
  $
  $
    cases(
      x_1-x_3=14,
      x_2+2x_3=-9,
    ) arrow.r.double
    cases(
      x_1=14+x_3,
      x_2=-9-2x_3
    )
  $
]
#example[
  $
    cases(
       &x_1+2&x_2+3&x_3&=7,
      2&x_1- &x_2+ &x_3&=4,
      3&x_1-2&x_2- &x_3&=3
    )
  $
  $
    mat(
      1, 2, 3, 7;
      2, -1, 1, 4;
      3, -2, -1, 3;
      augment: #3
    ) ~
    mat(
      1, 2, 3, 7;
      0, -5, -5, -10;
      0, -8, -10, -18;
      augment: #3
    ) ~ ... ~
    mat(
      1, 0, 0, 2;
      0, 1, 0, 1;
      0, 0, 1, 1;
      augment: #3
    ) arrow.r.double
    cases(
      x_1=2,
      x_2=1,
      x_3=1
    )
  $
]

#example[
  $
    cases(
      2&x_1+3&x_2+ &x_3-2&x_4&=9,
      7&x_1+8&x_2- &x_3-2&x_4&=5,
      3&x_1+2&x_2-3&x_3+2&x_4&=10
    )
  $
  $
    mat(
      2,3,1,-2,9;
      7,8,-1,-2,5;
      3,2,-3,2,10;
      augment: #4
    ) ~
    mat(
      2,3,1,-2,9;
      9, 11, 0, -4, 14;
      9, 11, 0, -4, 37;
      augment: #4
    ) ~
    mat(
      2,3,1,-2,9;
      9, 11, 0, -4, 14;
      0,0,0,0,23;
      augment: #4
    ) arrow.r.double "задача неразрешима"
  $
]

== Симплекс метод
Симплекс метод состоит из двух этапов.
1. Поиск опорного решения (допустимого решения)
2. Поиск оптимального решения

Будем рассматривать второй этап симплекс метода. Будем пологать, что задача записана в каноническом виде и выделены базисные переменные. Пусть есть $r$ базисных переменных ($x_1, x_2, ..., x_r$). Остальные переменные -- свободные. Все свободные неотрицательны.
$
  cases(
    x_1 + ... + a_(1 r+1) x_(r+1) + ... + a_(1 n)x_n &= b_1,
    x_2 + ...  &= b_2,
    ...,
    x_r + ...  &= b_r,
  )
$
$vec(b_1, b_2, ..., b_4)$---опорное решение.
Исключаем из целевой функции все базисные переменные. И записываем целевую функцию в виде:
$
  f + c_(r+1)x_(r+1) + ... + c_n x_n=c_0
$
На основании полученных записей рисуем симплекс таблицу.
#figure(
  table(
    columns: (auto, auto, 3em, 3em, 2em, 3em),
    align: horizon,
    inset: 7pt,
    [Базисные\
      неизвестные],
    [Свободный\
      член],
    [$x_1$],
    [$x_2$],
    [...],
    [$x_n$],

    [$x_1$], [$b_1$], [], [], [], [],
    table.cell(colspan: 6)[$dots.v$],
    [f], [$c_0$], [], [], [], []
  ),
)
Последняя строка --- строка оценок. Предположим, что решается задача минимизации. В строке оценок выбираем максимальную положительную оценку. Если положительных оценок нет, то получено оптимальное решение. Столбец в котором она находится называется разрешающим столбцом.

Дальше рассмотрим все неотрицательные отношения элемента к $x_i$.
$
  min{b_i / a_(i j)}=b_r / a_(r j)
$
далее производится один шаг по методу Гаусса. Процедура повторяется до получения оптимального решения.

Если положительных элементов в разрешающем столбце нет, то задача ЛП не имеет решения. То есть $f_min=-oo$.
